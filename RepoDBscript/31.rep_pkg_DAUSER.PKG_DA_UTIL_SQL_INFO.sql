-- DDL Script was generated by Orange for ORACLE

CREATE OR REPLACE PACKAGE DAUSER.PKG_DA_UTIL_SQL_INFO AS
/*****************************************************************************************************
   NAME:     DAUSER.PKG_DA_UTIL_SQL_INFO
   PURPOSE:  각 DB의 SQLNAME정보 추출
   REVISIONS:
   Ver        Date        Author               Description
   ---------  ----------  -------------------  --------------------------------
   1.0        2019-03-10                 1. 최초생성
******************************************************************************************************/

  /*******************************************************
    상품정보 생성 / 갱신 / 삭제
  *******************************************************/
  PROCEDURE SP_SQLNAME_MAPP(
	    P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD')
  );
  
  PROCEDURE SP_DA_SQLNAME_LIST(
	    P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD')
  );
  
  PROCEDURE SP_DA_SQLNAME_DTL_INFO
    (
        P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD')
    );
  
  PROCEDURE SP_DA_STATS(
	    P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD'),
        P_DB_ID     IN  NUMBER    DEFAULT 1
  );
  
  PROCEDURE SP_PROC_EXECUTE(
	    P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD')
  );
  
  PROCEDURE SP_PROC_LOG_INSERT(
        P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD'),
        P_STAT_NM   IN  VARCHAR2  ,
        P_DB_ID     IN  NUMBER    DEFAULT 12, --12는 DQMDB
        V_TRT_CNT   IN  NUMBER    DEFAULT 0
  );
  
  PROCEDURE SP_KPI_STATS(
        P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD')
  );

END;
/

CREATE OR REPLACE PACKAGE BODY DAUSER.PKG_DA_UTIL_SQL_INFO is
/*****************************************************************************
   NAME:     DAUSER.PKG_DA_UTIL_SQL_INFO
   PURPOSE:

   REVISIONS:
   Ver        Date        Author               Description
   ---------  ----------  -------------------  -------------------------------
   0.3        2020.05.06  노영삼                DA_SQLNAME_MAPP -> DA_SQLNAME_EXEC_INFO 으로 변경
   
   NOTES:        
   1. DA_SQLNAME_MAPP 은 SQLID, SQLNAME, DB, KPI 의 Statistic Delta value 를 계산하기 위해서만 사용.

******************************************************************************/
PROCEDURE SP_SQLNAME_MAPP
(
    P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD')
)
IS
    V_CLCT_DY VARCHAR2(8) ;
    V_PART_CD VARCHAR2(2) ;
    V_PART_CD2 VARCHAR2(2) ;
    V_STAT_NM VARCHAR2(64) := 'DA_SQLNAME_MAPP';
    V_TRT_CNT NUMBER := 0;
    
BEGIN

    V_CLCT_DY := P_CLCT_DY;
    V_PART_CD := TO_CHAR(TO_DATE(V_CLCT_DY,'YYYYMMDD'),'DD');
    V_PART_CD2 := TO_CHAR(TO_DATE(V_CLCT_DY, 'YYYYMMDD') - 1 , 'DD');
    -- V_PART_CD2 := TO_CHAR(TO_DATE(V_CLCT_DY - 1,'YYYYMMDD'),'DD');
    
    EXECUTE IMMEDIATE 'ALTER TABLE DAUSER.DA_SQLAREA TRUNCATE PARTITION P_DAY_'||V_PART_CD2||'';
    
    EXECUTE IMMEDIATE 'ALTER TABLE DA_SQLNAME_MAPP TRUNCATE PARTITION P_'||V_PART_CD||'';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE DA_SQLNAME_EXEC_INFO';

    INSERT /*+ APPEND */ ALL
    INTO DA_SQLNAME_MAPP
     (CLCT_DY, PART_CD, DB_ID, SQL_NAME, SQL_ID, RNK, INST_ID, SQL_TEXT, MODULE, LAST_ACTIVE_TIME
     , EXECUTIONS, BUFFER_GETS, ELAPSED_TIME, CPU_TIME, DISK_READS
     , COMMAND_TYPE, PARSING_SCHEMA_NAME, ROWS_PROCESSED, PROGRAM_ID, FIRST_LOAD_TIME ) VALUES
     (CLCT_DY,  PART_CD, DB_ID, SQL_NAME, SQL_ID, RNK, INST_ID, SQL_TEXT, MODULE, LAST_ACTIVE_TIME
     , EXECUTIONS, BUFFER_GETS, ELAPSED_TIME, CPU_TIME, DISK_READS
     , COMMAND_TYPE, PARSING_SCHEMA_NAME, ROWS_PROCESSED, PROGRAM_ID, FIRST_LOAD_TIME )
    INTO DA_SQLNAME_EXEC_INFO
     (DB_ID, SQL_ID, INST_ID, SQL_NAME, RNK, MODULE, FIRST_LOAD_TIME, LAST_ACTIVE_TIME
     , PROGRAM_ID, PARSING_SCHEMA_NAME
     , EXECUTIONS, BUFFER_GETS, ROWS_PROCESSED, CPU_TIME, ELAPSED_TIME, UPDATE_DT ) VALUES
     (DB_ID, SQL_ID, INST_ID, SQL_NAME, RNK
     , MODULE, FIRST_LOAD_TIME, LAST_ACTIVE_TIME, PROGRAM_ID, PARSING_SCHEMA_NAME
     , EXECUTIONS, BUFFER_GETS, ROWS_PROCESSED, CPU_TIME, ELAPSED_TIME, SYSDATE )
    WITH V_SQL_TEXT AS
    (
        SELECT  /*+ PARALLEL(A 8) FULL(A)*/
                CLCT_DY,
                PART_CD,
                (SELECT DB_ID FROM DA_DB_LIST WHERE DB_NM = A.DB_NM AND ROWNUM<=1) AS DB_ID,
                SQL_ID, 
                INST_ID, 
                EXECUTIONS,
                BUFFER_GETS,
                ELAPSED_TIME,
                CPU_TIME,
                DISK_READS,
                SQL_TEXT, 
                MODULE,
                PROGRAM_ID,
    --            (SELECT OBJECT_NAME FROM DBA_OBJECTS WHERE OBJECT_ID = B.PROGRAM_ID) AS OBJECT_NAME, --나중에 추가하자
                COMMAND_TYPE, PARSING_SCHEMA_NAME, LAST_ACTIVE_TIME, FIRST_LOAD_TIME, ROWS_PROCESSED
        FROM  DAUSER.DA_SQLAREA A
        WHERE CLCT_DY = V_CLCT_DY
        AND   PART_CD = V_PART_CD
        AND   PARSING_SCHEMA_NAME NOT IN ( 'SYS', 'SYSMAN', 'DBSNMP', 'SYSTEM', 'EXFSYS' )
        AND   NOT REGEXP_LIKE( nvl( MODULE, '-' ), 'Orange|SQL Developer|SQLGate|Data Pump|TOAD|golden|ERwin|PL.SQL Developer|SQL Loader|sqlplus|SQL.Plus' )
    )
    SELECT CLCT_DY,
           PART_CD,
           DB_ID,
           TRIM(SQL_NAME) AS SQL_NAME, 
           SQL_ID, 
           RNK,
           INST_ID, 
           SUBSTR(SQL_TEXT, 1,500) AS SQL_TEXT, 
           MODULE,
           PROGRAM_ID,
           FIRST_LOAD_TIME,
           LAST_ACTIVE_TIME, 
           EXECUTIONS, 
           BUFFER_GETS,
           ROWS_PROCESSED,
           ELAPSED_TIME,
           CPU_TIME,
           DISK_READS,
           COMMAND_TYPE,
           PARSING_SCHEMA_NAME
    FROM
    (
        SELECT S.*,
               ROW_NUMBER() OVER(PARTITION BY SQL_NAME, DB_ID ORDER BY EXECUTIONS DESC, LAST_ACTIVE_TIME DESC) AS RNK
        FROM
        (
            SELECT A.*,
                   PKG_SQL_SCRIPT.GET_SQL_NAME(SQL_TEXT) SQL_NAME
            FROM V_SQL_TEXT A 
        )S
    ) S
    ;
    
    V_TRT_CNT := sql%rowcount;
    COMMIT;
    
    SP_PROC_LOG_INSERT(V_CLCT_DY,V_STAT_NM,12, V_TRT_CNT);

END SP_SQLNAME_MAPP;


PROCEDURE SP_DA_SQLNAME_LIST
(
    P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD')
)
IS
    V_CLCT_DY VARCHAR2(8) ;
    V_PART_CD VARCHAR2(2) ;
    V_STAT_NM VARCHAR2(64) := 'DA_SQLNAME_LIST';
    
BEGIN
    V_CLCT_DY := P_CLCT_DY;
    V_PART_CD := TO_CHAR(TO_DATE(V_CLCT_DY,'YYYYMMDD'),'DD');
    
    -- SQLNAME 기준 정보 생성
    --기등록 SQL은 나머지 정보 업데이트 
    MERGE INTO DAUSER.DA_SQLNAME_LIST X
    USING
    (
        SELECT B.SQL_NAME_NO,
               A.REP_SQL_ID,
               A.PARSING_SCHEMA_NAME,
               A.MODULE,
               A.LAST_ACTIVE_TIME,
               SYSDATE AS CREATE_DT, 
               SYSDATE AS UPDATE_DT 
        FROM 
        (
            SELECT /*+ PARALLEL(A 8) FULL(A)*/
                   SQL_NAME, 
                   DB_ID, 
                   MAX(decode(rnk, 1, SQL_ID, null)) AS REP_SQL_ID,
                   MAX(PARSING_SCHEMA_NAME) AS PARSING_SCHEMA_NAME,
                   MAX(MODULE) AS MODULE,
                   MAX(LAST_ACTIVE_TIME) AS LAST_ACTIVE_TIME
            FROM DAUSER.DA_SQLNAME_MAPP  A
--            FROM DAUSER.DA_SQLNAME_EXEC_INFO  A
            WHERE 1=1
            AND CLCT_DY = V_CLCT_DY
            -- AND RNK = 1
            GROUP BY SQL_NAME, DB_ID
        ) A, DAUSER.DA_SQLNAME_LIST B 
        WHERE A.SQL_NAME = B.SQL_NAME
        AND A.DB_ID = B.DB_ID
        AND (
             A.REP_SQL_ID <> B.REP_SQL_ID 
             OR A.PARSING_SCHEMA_NAME <> B.PARSING_SCHEMA_NAME 
             OR A.MODULE <> B.MODULE 
             OR A.LAST_ACTIVE_TIME <> B.LAST_ACTIVE_TIME
            )
    )Y
    ON ( X.SQL_NAME_NO = Y.SQL_NAME_NO)
        WHEN MATCHED THEN
        UPDATE SET
        REP_SQL_ID          = Y.REP_SQL_ID,
        PARSING_SCHEMA_NAME = Y.PARSING_SCHEMA_NAME,
        MODULE              = Y.MODULE,
        LAST_ACTIVE_TIME    = Y.LAST_ACTIVE_TIME,
        UPDATE_DT           = SYSDATE
        ;
    SP_PROC_LOG_INSERT(V_CLCT_DY,'DA_SQLNAME_LIST-UPDATE',12, SQL%ROWCOUNT);
    
    -- 신규 SQL INSERT 
    INSERT INTO DAUSER.DA_SQLNAME_LIST
    (
       SQL_NAME_NO,
       DB_ID,
       SQL_NAME,
       REP_SQL_ID,
       PARSING_SCHEMA_NAME,
       MODULE,
       LAST_ACTIVE_TIME,
       CREATE_DT,
       UPDATE_DT 
    )
    SELECT 
           SEQ_DA_SQLNAME_LIST.NEXTVAL AS SQL_NAME_NO,
           A.DB_ID,
           A.SQL_NAME,
           A.REP_SQL_ID,
           A.PARSING_SCHEMA_NAME,
           A.MODULE,
           A.LAST_ACTIVE_TIME,
           SYSDATE AS CREATE_DT,
           SYSDATE AS UPDATE_DT 
    FROM 
    (
        SELECT A.*
        FROM 
        (
            SELECT /*+ PARALLEL(A 8) FULL(A)*/
                   SQL_NAME, 
                   DB_ID, 
                   MAX(decode(rnk, 1, SQL_ID, null)) AS REP_SQL_ID,
                   MAX(PARSING_SCHEMA_NAME) AS PARSING_SCHEMA_NAME,
                   MAX(MODULE) AS MODULE,
                   MAX(LAST_ACTIVE_TIME) AS LAST_ACTIVE_TIME
--            FROM DA_SQLNAME_EXEC_INFO A
--            WHERE RNK = 1
            FROM  DAUSER.DA_SQLNAME_MAPP  A
            WHERE CLCT_DY = V_CLCT_DY
            AND   PART_CD = V_PART_CD
--            AND   RNK = 1
            GROUP BY SQL_NAME, DB_ID
        ) A, DAUSER.DA_SQLNAME_LIST B 
        WHERE A.SQL_NAME = B.SQL_NAME(+) 
        AND A.DB_ID = B.DB_ID(+) 
        AND B.DB_ID IS NULL
        ORDER BY A.DB_ID,A.SQL_NAME
    ) A
    ;
    COMMIT;
    SP_PROC_LOG_INSERT(V_CLCT_DY,'DA_SQLNAME_LIST-INSERT',12, SQL%ROWCOUNT);

    -- SQLID 기준 정보 생성.
    MERGE INTO DAUSER.DA_SQLID_LIST X
    USING 
    (
        SELECT /*+ PARALLEL(A 8) FULL(A) USE_HASH(N) LEADING(N) */
            a.DB_ID DB_ID, 
            a.sql_id SQL_ID,
            MAX(a.SQL_NAME) SQL_NAME,
            MAX(N.SQL_NAME_NO) SQL_NAME_NO,
            MAX(a.MODULE) AS MODULE,
            MIN(A.FIRST_LOAD_TIME) FIRST_LOAD_TIME,
            MAX(a.LAST_ACTIVE_TIME) AS LAST_ACTIVE_TIME,
            MAX(a.PROGRAM_ID) AS PROGRAM_ID,
            MAX(a.PARSING_SCHEMA_NAME) AS PARSING_SCHEMA_NAME
--        FROM DA_SQLNAME_EXEC_INFO A, DA_SQLNAME_LIST N
        FROM DA_SQLNAME_MAPP A, DA_SQLNAME_LIST N
        WHERE 1=1
        AND  CLCT_DY = V_CLCT_DY
        AND  PART_CD = V_PART_CD
        and  A.DB_ID = N.DB_ID
        AND  A.SQL_name = N.SQL_name
        GROUP BY a.sql_id, a.DB_ID
        ) Y
    ON (X.DB_ID = Y.DB_ID
        AND X.SQL_ID = Y.SQL_ID)
    WHEN MATCHED THEN 
    UPDATE SET 
    --  X.SQL_NAME            = Y.SQL_NAME           
    --, X.SQL_NAME_NO         = Y.SQL_NAME_NO        
        X.MODULE              = Y.MODULE
    --    , X.FIRST_LOAD_TIME     = Y.FIRST_LOAD_TIME
        , X.LAST_ACTIVE_TIME    = Y.LAST_ACTIVE_TIME
        , X.PROGRAM_ID          = Y.PROGRAM_ID
        , X.PARSING_SCHEMA_NAME = Y.PARSING_SCHEMA_NAME
    , X.UPDATE_DT           = SYSDATE
    WHERE (1=0
        OR NVL(X.MODULE             ,'') <> NVL(Y.MODULE             , '')
    --    OR NVL(X.FIRST_LOAD_TIME    ,'') <> NVL(Y.FIRST_LOAD_TIME    , '')
        OR NVL(X.LAST_ACTIVE_TIME   ,'') <> NVL(Y.LAST_ACTIVE_TIME   , '')
        OR NVL(X.PROGRAM_ID         ,'') <> NVL(Y.PROGRAM_ID         , '')
        OR NVL(X.PARSING_SCHEMA_NAME,'') <> NVL(Y.PARSING_SCHEMA_NAME, '')
    )
    WHEN NOT MATCHED THEN
    INSERT (DB_ID, SQL_ID, SQL_NAME, SQL_NAME_NO, MODULE, FIRST_LOAD_TIME, LAST_ACTIVE_TIME, PROGRAM_ID, PARSING_SCHEMA_NAME, UPDATE_DT )
    VALUES (Y.DB_ID, Y.SQL_ID, Y.SQL_NAME, Y.SQL_NAME_NO, Y.MODULE, Y.FIRST_LOAD_TIME, Y.LAST_ACTIVE_TIME, Y.PROGRAM_ID, Y.PARSING_SCHEMA_NAME, SYSDATE);
    
    COMMIT;    
    SP_PROC_LOG_INSERT(V_CLCT_DY,'DA_SQLID_LIST',12, SQL%ROWCOUNT);


    SP_PROC_LOG_INSERT(V_CLCT_DY,V_STAT_NM,12);

END SP_DA_SQLNAME_LIST;


PROCEDURE SP_DA_SQLNAME_DTL_INFO
(
    P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD')
)
IS
    V_CLCT_DY VARCHAR2(8) ;
    V_PART_CD VARCHAR2(2) ;
    V_STAT_NM VARCHAR2(64) := 'DA_SQLNAME_DTL_INFO';
    V_TRT_CNT NUMBER := 0;
    
BEGIN
    V_CLCT_DY := P_CLCT_DY;
    V_PART_CD := TO_CHAR(TO_DATE(V_CLCT_DY,'YYYYMMDD'),'DD');

    --SQLNAME Ref.Object 정보 입력
    --SQLName 별로 참조 테이블이 제거될 경우 로직 미구현.
    INSERT INTO DAUSER.DA_SQLNAME_DTL_INFO
    (
       SQL_NAME_NO,
       OWNER,
       OBJECT_NAME,
       OBJECT_TYPE,
       CREATE_DT,
       UPDATE_DT
    )
    SELECT /*+ LEADING(A B C) USE_HASH(A B C)*/
           A.SQL_NAME_NO,
           C.OWNER,
           C.OBJECT_NAME,
           C.OBJECT_TYPE,
           SYSDATE AS CREATE_DT,
           SYSDATE AS UPDATE_DT 
    FROM   DA_SQLNAME_LIST A,
           DA_SQLNAME_DTL_INFO B,
           (
                SELECT /*+ NO_MERGE*/B.DB_ID, 
                       A.CLCT_DY
                     , A.DB_NM
                     , A.SQL_ID
                     , A.OWNER
                     , A.OBJECT_NAME
                     , A.OBJECT_TYPE
                     , A.CREATE_DT 
                FROM  DA_SQL_DEPENDENCY A, DA_DB_LIST B 
                WHERE A.CLCT_DY = V_CLCT_DY
                AND   A.DB_NM = B.DB_NM
           ) C
    WHERE A.SQL_NAME_NO = B.SQL_NAME_NO(+)
    AND B.SQL_NAME_NO IS NULL
    AND A.DB_ID = C.DB_ID 
    AND A.REP_SQL_ID = C.SQL_ID
    ORDER BY A.SQL_NAME_NO,B.OWNER,B.OBJECT_TYPE,B.OBJECT_NAME
    ;
    
    V_TRT_CNT := SQL%ROWCOUNT;
    
    COMMIT;


    SP_PROC_LOG_INSERT(V_CLCT_DY,V_STAT_NM,12, V_TRT_CNT);

END SP_DA_SQLNAME_DTL_INFO;


PROCEDURE SP_DA_STATS
(
    P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD'),
    P_DB_ID     IN  NUMBER    DEFAULT 1
)
IS
    V_CURR_CLCT_DY VARCHAR2(8) ;
    V_CURR_PART_CD VARCHAR2(2) ;
    
    V_PREV_CLCT_DY VARCHAR2(8) ;
    V_PREV_PART_CD VARCHAR2(2) ;
    
    V_STAT_NM VARCHAR2(64) := 'DA_DB_STATS';
BEGIN
    
    V_CURR_CLCT_DY := P_CLCT_DY;
    V_CURR_PART_CD := TO_CHAR(TO_DATE(V_CURR_CLCT_DY,'YYYYMMDD'),'DD');
    
    V_PREV_CLCT_DY := TO_CHAR(TO_DATE(V_CURR_CLCT_DY,'YYYYMMDD') - 1,'YYYYMMDD');
    V_PREV_PART_CD := TO_CHAR(TO_DATE(V_CURR_CLCT_DY,'YYYYMMDD') - 1,'DD');
    
    
    DELETE FROM DAUSER.DA_SQLID_STATS
    WHERE CLCT_DY = V_CURR_CLCT_DY
    AND   DB_ID = P_DB_ID
    ;

    INSERT INTO DAUSER.DA_SQLID_STATS
    (
           CLCT_DY,
           DB_ID,
           SQL_ID,
           SQL_NAME,
           CURR_TOTAL_EXEC,
           PREV_TOTAL_EXEC,
           EXEC_DIFF,
           CURR_TOTAL_BGET,
           PREV_TOTAL_BGET,
           BGET_DIFF,
           CURR_TOTAL_CPU,
           PREV_TOTAL_CPU,
           CPU_DIFF,
           CURR_TOTAL_ELA,
           PREV_TOTAL_ELA,
           ELA_DIFF,
           CURR_CLCT_DY, 
           PREV_CLCT_DY ,
           CREATE_DT 
    )
    WITH CURR AS 
    (
        SELECT CLCT_DY, DB_ID, SQL_ID, INST_ID, MAX(SQL_NAME) AS SQL_NAME, 
               SUM(EXECUTIONS) EXECUTIONS, SUM(BUFFER_GETS) BUFFER_GETS, SUM(CPU_TIME) CPU_TIME, SUM(ELAPSED_TIME) ELAPSED_TIME
        FROM 
        (
            SELECT /*+ PARALLEL(S 8) FULL(S) */ CLCT_DY, DB_ID, SQL_NAME
                    , INST_ID, SQL_ID
            ,       EXECUTIONS, BUFFER_GETS, CPU_TIME, ELAPSED_TIME
            FROM  DAUSER.DA_SQLNAME_MAPP S 
            WHERE CLCT_DY = V_CURR_CLCT_DY
            AND   PART_CD = V_CURR_PART_CD
            AND   DB_ID = P_DB_ID
        ) A
        GROUP BY CLCT_DY, DB_ID, SQL_ID, INST_ID
    ), 
    PREV AS                                                                                     
    (
        SELECT CLCT_DY, DB_ID, SQL_ID, INST_ID, MAX(SQL_NAME) AS SQL_NAME, 
               SUM(EXECUTIONS) EXECUTIONS, SUM(BUFFER_GETS) BUFFER_GETS, SUM(CPU_TIME) CPU_TIME, SUM(ELAPSED_TIME) ELAPSED_TIME
        FROM 
        (
            SELECT /*+ PARALLEL(S 8) FULL(S) */ CLCT_DY, DB_ID, SQL_NAME
                    , INST_ID, SQL_ID
            ,       EXECUTIONS, BUFFER_GETS, CPU_TIME, ELAPSED_TIME
            FROM  DAUSER.DA_SQLNAME_MAPP S 
            WHERE CLCT_DY = V_PREV_CLCT_DY
            AND   PART_CD =V_PREV_PART_CD
            AND   DB_ID = P_DB_ID
        ) A
        GROUP BY CLCT_DY, DB_ID, SQL_ID,INST_ID
    )
    SELECT CLCT_DY,
           DB_ID,
           SQL_ID,
           SQL_NAME,
           CURR_TOTAL_EXEC,
           PREV_TOTAL_EXEC,
           CASE WHEN EXEC_DIFF < 0 THEN 0 ELSE EXEC_DIFF END AS EXEC_DIFF,
           CURR_TOTAL_BGET,
           PREV_TOTAL_BGET,
           CASE WHEN BGET_DIFF < 0 THEN 0 ELSE BGET_DIFF END AS BGET_DIFF,           
           CURR_TOTAL_CPU,
           PREV_TOTAL_CPU,
           CASE WHEN CPU_DIFF < 0 THEN 0 ELSE CPU_DIFF END AS CPU_DIFF,    
           CURR_TOTAL_ELA,
           PREV_TOTAL_ELA,
           CASE WHEN ELA_DIFF < 0 THEN 0 ELSE ELA_DIFF END AS ELA_DIFF,           
           CURR_CLCT_DY,
           PREV_CLCT_DY,
           SYSDATE AS CREATE_DT
    FROM 
    (
        SELECT 
              A.CLCT_DY
             ,A.DB_ID
             ,A.SQL_ID
             ,MAX(A.SQL_NAME) AS SQL_NAME
             ,SUM(A.CURR_TOTAL_EXEC)   AS CURR_TOTAL_EXEC
             ,SUM(A.PREV_TOTAL_EXEC)   AS PREV_TOTAL_EXEC
             ,SUM(A.EXEC_DIFF)    AS EXEC_DIFF
             ,SUM(A.CURR_TOTAL_BGET)  AS CURR_TOTAL_BGET
             ,SUM(A.PREV_TOTAL_BGET)  AS PREV_TOTAL_BGET
             ,SUM(A.BGET_DIFF)    AS BGET_DIFF
             ,SUM(A.CURR_TOTAL_CPU)     AS CURR_TOTAL_CPU
             ,SUM(A.PREV_TOTAL_CPU)     AS PREV_TOTAL_CPU
             ,SUM(A.CPU_DIFF)     AS CPU_DIFF
             ,SUM(A.CURR_TOTAL_ELA) AS CURR_TOTAL_ELA
             ,SUM(A.PREV_TOTAL_ELA) AS PREV_TOTAL_ELA       
             ,SUM(A.ELA_DIFF)     AS ELA_DIFF    
             ,MAX(A.CLCT_DY) AS CURR_CLCT_DY
             ,MAX(A.PREV_CLCT_DY) AS PREV_CLCT_DY 
        FROM 
        (
            SELECT    /*+ LEADING(A B) USE_HASH(B)*/
                      A.CLCT_DY
                     ,A.DB_ID
                     ,A.SQL_ID
                     ,A.INST_ID
                     ,A.SQL_NAME
                     ,A.EXECUTIONS   CURR_TOTAL_EXEC
                     ,B.EXECUTIONS   PREV_TOTAL_EXEC
                     ,CASE WHEN (A.EXECUTIONS - NVL(B.EXECUTIONS,0)) < 0 THEN 0 
                           ELSE (A.EXECUTIONS - NVL(B.EXECUTIONS,0))
                      END AS EXEC_DIFF
                     ,A.BUFFER_GETS   CURR_TOTAL_BGET
                     ,B.BUFFER_GETS   PREV_TOTAL_BGET
                     ,CASE WHEN (A.BUFFER_GETS - NVL(B.BUFFER_GETS,0)) < 0 THEN 0  
                           ELSE (A.BUFFER_GETS - NVL(B.BUFFER_GETS,0)) 
                      END AS BGET_DIFF
                     ,A.CPU_TIME   CURR_TOTAL_CPU
                     ,B.CPU_TIME   PREV_TOTAL_CPU
                     ,CASE WHEN (A.CPU_TIME - NVL(B.CPU_TIME,0)) < 0 THEN 0  
                           ELSE (A.CPU_TIME - NVL(B.CPU_TIME,0))
                      END AS CPU_DIFF
                     ,A.ELAPSED_TIME   CURR_TOTAL_ELA
                     ,B.ELAPSED_TIME   PREV_TOTAL_ELA      
                     ,CASE WHEN (A.ELAPSED_TIME - NVL(B.ELAPSED_TIME,0)) < 0 THEN 0  
                           ELSE (A.ELAPSED_TIME - NVL(B.ELAPSED_TIME,0))
                      END AS ELA_DIFF                     
                     ,A.CLCT_DY AS CURR_CLCT_DY
                     ,B.CLCT_DY AS PREV_CLCT_DY         
            FROM CURR A, PREV B
            WHERE 1=1
            --AND A.INST_ID = B.INST_ID
            AND A.SQL_ID = B.SQL_ID(+)
            AND A.DB_ID =  B.DB_ID(+)
            AND A.INST_ID =  B.INST_ID(+)
        ) A 
        GROUP BY A.CLCT_DY, A.SQL_ID, A.DB_ID 
    ) A
    ;
    
    
    DELETE FROM DAUSER.DA_SQLNAME_STATS
    WHERE CLCT_DY = V_CURR_CLCT_DY
    AND   DB_ID = P_DB_ID
    ; 
    
    INSERT INTO DAUSER.DA_SQLNAME_STATS
    (
           CLCT_DY,
           DB_ID,
           SQL_NAME_NO,
           CURR_TOTAL_EXEC,
           PREV_TOTAL_EXEC,
           EXEC_DIFF,
           CURR_TOTAL_BGET,
           PREV_TOTAL_BGET,
           BGET_DIFF,
           CURR_TOTAL_CPU,
           PREV_TOTAL_CPU,
           CPU_DIFF,
           CURR_TOTAL_ELA,
           PREV_TOTAL_ELA,
           ELA_DIFF,
           CURR_CLCT_DY, 
           PREV_CLCT_DY ,
           CREATE_DT 
    )
    SELECT  A.CLCT_DY, 
            A.DB_ID, 
            B.SQL_NAME_NO,
            A.CURR_TOTAL_EXEC,
            A.PREV_TOTAL_EXEC,
            A.EXEC_DIFF,
            A.CURR_TOTAL_BGET,
            A.PREV_TOTAL_BGET,
            A.BGET_DIFF,
            A.CURR_TOTAL_CPU,
            A.PREV_TOTAL_CPU,
            A.CPU_DIFF,
            A.CURR_TOTAL_ELA,
            A.PREV_TOTAL_ELA,
            A.ELA_DIFF,
            A.CURR_CLCT_DY,
            A.PREV_CLCT_DY,
            SYSDATE AS CREATE_DT 
    FROM 
    (
        SELECT /*+ FULL(A) PARALLEL(A 4)*/
               CLCT_DY, 
               DB_ID, 
               SQL_NAME,
               SUM(A.CURR_TOTAL_EXEC) AS CURR_TOTAL_EXEC,
               SUM(A.PREV_TOTAL_EXEC) AS PREV_TOTAL_EXEC,
               SUM(A.EXEC_DIFF) AS EXEC_DIFF,
               SUM(A.CURR_TOTAL_BGET) AS CURR_TOTAL_BGET,
               SUM(A.PREV_TOTAL_BGET) AS PREV_TOTAL_BGET,
               SUM(A.BGET_DIFF) AS BGET_DIFF,
               SUM(A.CURR_TOTAL_CPU) AS CURR_TOTAL_CPU,
               SUM(A.PREV_TOTAL_CPU) AS PREV_TOTAL_CPU,
               SUM(A.CPU_DIFF) AS CPU_DIFF,
               SUM(A.CURR_TOTAL_ELA) AS CURR_TOTAL_ELA,
               SUM(A.PREV_TOTAL_ELA) AS PREV_TOTAL_ELA,
               SUM(A.ELA_DIFF) AS ELA_DIFF,
               MAX(A.CURR_CLCT_DY) AS CURR_CLCT_DY,
               MAX(A.PREV_CLCT_DY) AS PREV_CLCT_DY
        FROM  DAUSER.DA_SQLID_STATS A
        WHERE CLCT_DY = V_CURR_CLCT_DY
        AND   DB_ID = P_DB_ID
        GROUP BY CLCT_DY, DB_ID, SQL_NAME
    ) A, DA_SQLNAME_LIST B 
    WHERE A.SQL_NAME = B.SQL_NAME
    AND   A.DB_ID = B.DB_ID
    ;
    
    
    DELETE FROM DA_DB_STATS
    WHERE CLCT_DY = V_CURR_CLCT_DY
    AND   DB_ID = P_DB_ID
    ; 


    INSERT INTO DA_DB_STATS
    (
        CLCT_DY,
        DB_ID,
        SQL_NAME_CNT,
        CURR_TOTAL_EXEC,
        PREV_TOTAL_EXEC,
        EXEC_DIFF,
        CURR_TOTAL_BGET,
        PREV_TOTAL_BGET,
        BGET_DIFF,
        CURR_TOTAL_CPU,
        PREV_TOTAL_CPU,
        CPU_DIFF,
        CURR_TOTAL_ELA,
        PREV_TOTAL_ELA,
        ELA_DIFF,
        CURR_CLCT_DY,
        PREV_CLCT_DY,
        CREATE_DT 
    )
    SELECT /*+ FULL(A) PARALLEL(A 4)*/
           CLCT_DY, 
           DB_ID, 
           COUNT(DISTINCT A.SQL_NAME_NO) AS SQL_CNT, 
           SUM(A.CURR_TOTAL_EXEC) AS CURR_TOTAL_EXEC,
           SUM(A.PREV_TOTAL_EXEC) AS PREV_TOTAL_EXEC,
           SUM(A.EXEC_DIFF) AS EXEC_DIFF,
           SUM(A.CURR_TOTAL_BGET) AS CURR_TOTAL_BGET,
           SUM(A.PREV_TOTAL_BGET) AS PREV_TOTAL_BGET,
           SUM(A.BGET_DIFF) AS BGET_DIFF,
           SUM(A.CURR_TOTAL_CPU) AS CURR_TOTAL_CPU,
           SUM(A.PREV_TOTAL_CPU) AS PREV_TOTAL_CPU,
           SUM(A.CPU_DIFF) AS CPU_DIFF,
           SUM(A.CURR_TOTAL_ELA) AS CURR_TOTAL_ELA,
           SUM(A.PREV_TOTAL_ELA) AS PREV_TOTAL_ELA,
           SUM(A.ELA_DIFF) AS ELA_DIFF,
           MAX(A.CURR_CLCT_DY) AS CURR_CLCT_DY,
           MAX(A.PREV_CLCT_DY) AS PREV_CLCT_DY,
           SYSDATE AS CREATE_DT
    FROM  DAUSER.DA_SQLNAME_STATS A
    WHERE CLCT_DY = V_CURR_CLCT_DY
    AND   DB_ID = P_DB_ID
    GROUP BY CLCT_DY, DB_ID
    ;
    
    COMMIT;
    
    SP_PROC_LOG_INSERT(V_CURR_CLCT_DY,V_STAT_NM,P_DB_ID);

END SP_DA_STATS;

PROCEDURE SP_KPI_STATS
(
    P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD')
)
IS
    V_CLCT_DY VARCHAR2(8) ;
BEGIN

    V_CLCT_DY := P_CLCT_DY;
    
    DELETE FROM DA_DB_KPI_STATS
    WHERE CLCT_DY = V_CLCT_DY
    AND   DB_ID IN(1,4,5,6,13)
    ; 
    
    INSERT INTO DA_DB_KPI_STATS
    SELECT CLCT_DY,
           DB_ID,
           SQL_NAME_CNT,
           ALL_SQL_NAME_CNT,
           ROUND(SQL_NAME_CNT/ALL_SQL_NAME_CNT * 100,2) AS SQL_NAME_CNT_RT,
           EXEC_DIFF,ALL_EXEC_DIFF,ROUND(EXEC_DIFF/ALL_EXEC_DIFF * 100,2) AS EXEC_RT,
           BGET_DIFF,ALL_BGET_DIFF,ROUND(BGET_DIFF/ALL_BGET_DIFF * 100,2) AS BGET_RT,
           CPU_DIFF,ALL_CPU_DIFF,ROUND(CPU_DIFF/ALL_CPU_DIFF * 100,2) AS CPU_RT,
           ELA_DIFF,ALL_ELA_DIFF,ROUND(ELA_DIFF/ALL_ELA_DIFF * 100,2) AS ELA_RT,
           SYSDATE
    FROM 
    (
        SELECT A.CLCT_DY,
               A.DB_ID,
               B.DB_NM,
               A.SQL_NAME_CNT, SUM(A.SQL_NAME_CNT) OVER() AS ALL_SQL_NAME_CNT,
               A.EXEC_DIFF, SUM(A.EXEC_DIFF) OVER() AS ALL_EXEC_DIFF,
               A.BGET_DIFF, SUM(A.BGET_DIFF) OVER() AS ALL_BGET_DIFF,
               A.CPU_DIFF, SUM(A.CPU_DIFF) OVER() AS ALL_CPU_DIFF,
               A.ELA_DIFF, SUM(A.ELA_DIFF) OVER() AS ALL_ELA_DIFF
        FROM DA_DB_STATS A, DA_DB_LIST B 
        WHERE CLCT_DY = V_CLCT_DY
        AND   A.DB_ID = B.DB_ID
        AND   A.DB_ID IN(1,4,5,6,13)
    )
    ;

    COMMIT;

END SP_KPI_STATS;

PROCEDURE SP_PROC_LOG_INSERT
(
    P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD'),
    P_STAT_NM   IN  VARCHAR2  ,
    P_DB_ID     IN  NUMBER    DEFAULT 12, --DB_NM 구별이 필요없는 경우,PMETA(12)값이 들어가게 한다.
    V_TRT_CNT   IN  NUMBER    DEFAULT 0 --DB_NM 구별이 필요없는 경우,PMETA(12)값이 들어가게 한다.
)
IS
    V_CLCT_DY VARCHAR2(8) ;
    V_STAT_NM VARCHAR2(64) ;
    V_DB_NM   VARCHAR2(64) ;
BEGIN

    V_CLCT_DY := P_CLCT_DY;
    V_STAT_NM := P_STAT_NM;
    
    SELECT DB_NM 
    INTO V_DB_NM 
    FROM DA_DB_LIST 
    WHERE DB_ID = P_DB_ID
    ;

    MERGE INTO DAUSER.DA_STAT_MNG A
    USING DUAL
    ON (A.DB_NM = V_DB_NM
        AND A.STAT_NM = V_STAT_NM
        AND A.CLCT_DY = V_CLCT_DY)
    WHEN MATCHED THEN
    UPDATE SET
        A.CLCT_RSLT_CD  = '01'
        , A.PART_CD  = NULL
        , UPDATE_DT = SYSDATE
        , TRT_CNT = V_TRT_CNT
    WHEN NOT MATCHED THEN
    INSERT (DB_NM,STAT_NM, CLCT_DY, CLCT_RSLT_CD, PART_CD, CREATE_DT, UPDATE_DT , TRT_CNT, TRT_CONT)
    VALUES (V_DB_NM, V_STAT_NM, V_CLCT_DY, '01', NULL, SYSDATE, SYSDATE, V_TRT_CNT, null);

    COMMIT;

END SP_PROC_LOG_INSERT;

PROCEDURE SP_PROC_EXECUTE
(
    P_CLCT_DY   IN  VARCHAR2  DEFAULT TO_CHAR(SYSDATE,'YYYYMMDD')
)
IS
    V_CLCT_DY  VARCHAR2(8) ;
    V_BATCH_NM VARCHAR2(100) := 'PKG_DA_UTIL_SQL_INFO.SP_PROC_EXECUTE';
    V_SYSDATE  DATE := SYSDATE; 
BEGIN

    V_CLCT_DY := P_CLCT_DY;

    V_BATCH_NM := 'PKG_DA_UTIL_SQL_INFO.SP_SQLNAME_MAPP';
    PKG_DA_UTIL_SQL_INFO.SP_SQLNAME_MAPP(V_CLCT_DY);
    
    V_BATCH_NM := 'PKG_DA_UTIL_SQL_INFO.SP_DA_SQLNAME_LIST';
    PKG_DA_UTIL_SQL_INFO.SP_DA_SQLNAME_LIST(V_CLCT_DY);
    V_BATCH_NM := 'PKG_DA_UTIL_SQL_INFO.SP_DA_SQLNAME_DTL_INFO';
    PKG_DA_UTIL_SQL_INFO.SP_DA_SQLNAME_DTL_INFO(V_CLCT_DY);
    
    V_BATCH_NM := 'PKG_DA_UTIL_SQL_INFO.SP_DA_STATS';
    PKG_DA_UTIL_SQL_INFO.SP_DA_STATS(V_CLCT_DY,1); --TMALL
    PKG_DA_UTIL_SQL_INFO.SP_DA_STATS(V_CLCT_DY,4); --DPDB
    PKG_DA_UTIL_SQL_INFO.SP_DA_STATS(V_CLCT_DY,5); --MPDB
    PKG_DA_UTIL_SQL_INFO.SP_DA_STATS(V_CLCT_DY,6); --CARTDB
    PKG_DA_UTIL_SQL_INFO.SP_DA_STATS(V_CLCT_DY,13); --PRMTDB
    PKG_DA_UTIL_SQL_INFO.SP_DA_STATS(V_CLCT_DY,8); --PSKPAY
    PKG_DA_UTIL_SQL_INFO.SP_DA_STATS(V_CLCT_DY,9); --PSKPAYPG
    PKG_DA_UTIL_SQL_INFO.SP_KPI_STATS(V_CLCT_DY); --CARTDB
    
    
/*
1	TMALL
2	BIDB
4	DPDB
5	MPDB
6	CARTDB
7	SOLDB
8	PSKPAY
9	PSKPAYPG
10	FDSDB
13	PRMTDB
*/

    COMMIT;
    
    
    V_BATCH_NM := 'PKG_DA_UTIL_SQL_INFO.SP_PROC_EXECUTE';
    PKG_DA_BATCH_LOG.SP_BATCH_LOG(V_BATCH_NM, V_SYSDATE,sysdate,'김미정',sqlcode,sqlerrm,'성공');
  

    --EXCEPTION 은 이 부분만 존재함. 
    EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      PKG_DA_BATCH_LOG.SP_BATCH_LOG(V_BATCH_NM, V_SYSDATE,sysdate,'김미정',sqlcode,sqlerrm,'에러');


END SP_PROC_EXECUTE;

END PKG_DA_UTIL_SQL_INFO;
/